# 589. N-ary Tree Preorder Traversal

Given the `root` of an n-ary tree, return _the preorder traversal of its nodes' values_.

Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)

**Example 1:**

![](https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png)

```
Input: root = [1,null,3,2,4,null,5,6]
Output:
 [1,3,5,6,2,4]
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2019/11/08/sample\_4\_964.png)

<pre><code>Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
<strong>Output:
</strong> [1,2,3,6,7,11,14,4,8,12,5,9,13,10]</code></pre>

**Constraints:**

* The number of nodes in the tree is in the range `[0, 104]`.
* `0 <= Node.val <= 104`
* The height of the n-ary tree is less than or equal to `1000`.

**Follow up:** Recursive solution is trivial, could you do it iteratively?

### TypeScript

**Result**

Runtime: 73 ms, faster than 95.84% of TypeScript online submissions for Longest Palindrome.&#x20;

Memory Usage: 45.4 MB, less than 30.02% of TypeScript online submissions for Longest Palindrome.

```typescript
const longestPalindrome = (s: string): number => {
    if (!s || s == "")
        return 0

    let count = 0
    const check = new Set();

    for (let i = 0; i < s.length; i++) {
        if (check.has(s[i])) {
            check.delete(s[i])
            count++
        } else {
            check.add(s[i])
        }
    }

    if (check.size != 0)
        return count * 2 + 1
    return count * 2
}
```

### Python

**Result**

Runtime: 35 ms, faster than 92.74% of Python3 online submissions for Longest Palindrome.&#x20;

Memory Usage: 13.9 MB, less than 67.12% of Python3 online submissions for Longest Palindrome.

```python
class Solution:
    def longestPalindrome(self, s: str) -> int:
        if s is None or s == "":
            return 0

        count = 0
        check = set()
        for i in range(len(s)):
            if s[i] in check:
                check.remove(s[i])
                count += 1
            else:
                check.add(s[i])

        if len(check) != 0:
            return count * 2 + 1
        return count * 2
```

### PHP

**Result**

Runtime: 13 ms, faster than 70.15% of PHP online submissions for Longest Palindrome.&#x20;

Memory Usage: 19.1 MB, less than 91.04% of PHP online submissions for Longest Palindrome.

```php
class Solution
{
    /**
     * @param String $s
     * @return Integer
     */
    function longestPalindrome(string $s): int
    {
        if (empty($s) || empty(strlen($s))) {
            return 0;
        }

        $count = 0;
        $check = [];
        for ($i = 0; $i < strlen($s); $i++) {
            if (isset($check[$s[$i]])) {
                unset($check[$s[$i]]);
                $count++;
            } else {
                $check[$s[$i]] = 1;
            }
        }
        if (count($check) != 0)
            return $count * 2 + 1;
        return $count * 2;
    }
}
```
