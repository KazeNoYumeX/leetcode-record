# 605. Can Place Flowers

You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in **adjacent** plots.

Given an integer array `flowerbed` containing `0`'s and `1`'s, where `0` means empty and `1` means not empty, and an integer `n`, return `true` _if_ `n` _new flowers can be planted in the_ `flowerbed` _without violating the no-adjacent-flowers rule and_ `false` _otherwise_.

**Example 1:**

```
Input: flowerbed = [1,0,0,0,1], n = 1
Output: true
```

**Example 2:**

```
Input: flowerbed = [1,0,0,0,1], n = 2
Output: false
```

**Constraints:**

* `1 <= flowerbed.length <= 2 * 10^4`
* `flowerbed[i]` is `0` or `1`.
* There are no two adjacent flowers in `flowerbed`.
* `0 <= n <= flowerbed.length`

### Python

**Result**

Runtime: 136 ms, Beats 97.60% of users with Python3

Memory Usage: 16.7 MB, Beats 78.82% of users with Python3

```python
class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
        if n == 0:
            return True

        length = len(flowerbed)

        i = 0
        while i < length:
            if flowerbed[i] == 1 :
                i += 2
            elif i + 1 >= length or flowerbed[i + 1] == 0:
                n -= 1
                i += 2
            else:
                i += 3
                
            if n == 0:
                return True

        return False
```

### PHP

**Result**

Runtime: 40 ms, Beats 86.14% of users with PHP

Memory Usage: 21.11 MB, Beats 8.91% of users with PHP

```php
class Solution
{
    /**
     * @param  Integer[]  $flowerbed
     * @param  Integer  $n
     * @return Boolean
     */
    public function canPlaceFlowers(array $flowerbed, int $n): bool
    {
        if ($n === 0) {
            return true;
        }

        $length = count($flowerbed);
        $i = 0;
        while ($i < $length) {
            if ($flowerbed[$i] == 1) {
                $i += 2;
            } elseif ($flowerbed[$i + 1] !== 1) {
                $n--;
                $i += 2;
            } else {
                $i += 3;
            }

            if ($n === 0) {
                return true;
            }
        }
        return false;
    }
}
```

### Go

**Result**

Runtime: 13 ms, Beats 88.55% of users with Go

Memory Usage: 6.28 MB, Beats 63.08% of users with Go

```go
func canPlaceFlowers(flowerbed []int, n int) bool {
	if n == 0 {
		return true
	}

	length := len(flowerbed)
	i := 0

	for i < length {
		if flowerbed[i] == 1 {
			i += 2
		} else if i+1 >= length || flowerbed[i+1] == 0 {
			n--
			i += 2
		} else {
			i += 3
		}

		if n == 0 {
			return true
		}
	}

	return false
}
```

### TypeScript

**Result**

Runtime: 42 ms, Beats 99.75% of users with TypeScript

Memory Usage: 44.8 MB, Beats 76.3% of users with TypeScript

```typescript
const canPlaceFlowers = (flowerbed: number[], n: number): boolean => {
    if (n == 0) {
        return true
    }

    const length = flowerbed.length
    let i = 0

    while (i < length) {
        if (flowerbed[i] == 1) {
            i += 2
        } else if (i + 1 >= length || flowerbed[i + 1] == 0) {
            n--
            i += 2
        } else {
            i += 3
        }

        if (n == 0) {
            return true
        }
    }

    return false
}
```
